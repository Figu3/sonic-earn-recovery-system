/**
 * Fix Snapshot Script
 *
 * Corrects the snapshot-62788943.json by:
 *
 * 1. Removing auto voter contract single-entry balances (V1, V2 USD, V2 ETH)
 *    and replacing them with correctly attributed per-depositor amounts.
 *
 * 2. Undoing the pro-rata redistribution of withdraw queue balances
 *    (which happened because totalSupply() reverted on the queue contracts)
 *    and replacing with correctly attributed per-participant amounts.
 *
 * Data sources (generated by on-chain event analysis):
 *   - /tmp/auto_voter_v1_resolved.json + /tmp/av1_additional_depositors.json + /tmp/av1_all_tokens.json
 *   - /tmp/auto_voter_v2_usd_resolved.json
 *   - /tmp/auto_voter_v2_eth_resolved.json
 *   - /tmp/withdraw_queues_resolved.json
 *
 * Usage:
 *   npx tsx scripts/fix-snapshot.ts
 */

import * as fs from "fs";
import * as path from "path";

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface SnapshotEntry {
  address: string;
  label?: string;
  stkscUSD_balance: string;
  stkscETH_balance: string;
  stkscUSD_share: string;
  stkscETH_share: string;
}

interface SnapshotFile {
  snapshotBlock: number;
  timestamp: string;
  stkscUSD: {
    totalSupply: string;
    decimals: number;
    holderCount: number;
  };
  stkscETH: {
    totalSupply: string;
    decimals: number;
    holderCount: number;
  };
  recursiveResolution: Record<string, number>;
  entitlements: SnapshotEntry[];
}

// â”€â”€â”€ Contract Addresses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const AUTO_VOTER_V1 = "0x6328a2ff2e6bb164f1be2479af209a88295f54d5";
const AUTO_VOTER_V2_USD = "0x605257994ffef290c9ed8f51e0bf68b2735c17a9";
const AUTO_VOTER_V2_ETH = "0x60f126d6eac8971ed0a755e9a72d1b9532bb5b99";

// Contracts to remove from entitlements (these are the auto voter contracts
// that appear as single holders but actually hold on behalf of many depositors)
const CONTRACTS_TO_REMOVE = new Set([
  AUTO_VOTER_V1,
  AUTO_VOTER_V2_USD,
  AUTO_VOTER_V2_ETH,
]);

// â”€â”€â”€ Data Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface ResolvedData {
  depositor_amounts: Record<string, number>;
  total_locked: number;
}

interface AllTokensData {
  all_token_ids: number[];
  token_amounts: Record<string, number>;
  unmapped_token_ids: number[];
  total_locked: number;
  mapped_amount: number;
  unmapped_amount: number;
}

interface AdditionalDepositors {
  [tokenId: string]: string; // tokenId -> depositor address
}

interface WithdrawQueueData {
  usd_withdraw_queue: {
    depositor_amounts: Record<string, number>;
    total_shares: number;
    depositor_count: number;
  };
  eth_withdraw_queue: {
    depositor_amounts: Record<string, number>;
    total_shares: number;
    depositor_count: number;
  };
}

function loadJson<T>(filePath: string): T {
  return JSON.parse(fs.readFileSync(filePath, "utf-8"));
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function main() {
  const scriptDir = path.dirname(decodeURIComponent(new URL(import.meta.url).pathname));
  const snapshotPath = path.join(scriptDir, "output", "snapshot-62788943.json");

  console.log("ğŸ“‹ Loading snapshot...");
  const snapshot: SnapshotFile = loadJson(snapshotPath);
  console.log(`   Block: ${snapshot.snapshotBlock}`);
  console.log(`   Entries: ${snapshot.entitlements.length}`);

  const usdTotalSupply = BigInt(snapshot.stkscUSD.totalSupply);
  const ethTotalSupply = BigInt(snapshot.stkscETH.totalSupply);
  const WAD = 10n ** 18n;

  console.log(`   stkscUSD totalSupply: ${usdTotalSupply}`);
  console.log(`   stkscETH totalSupply: ${ethTotalSupply}`);

  // â”€â”€ Load resolved data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ“‚ Loading resolved data...");

  // Auto Voter V1: Combine main resolved + additional depositors + all tokens
  const av1Resolved: ResolvedData = loadJson("/tmp/auto_voter_v1_resolved.json");
  const av1Additional: AdditionalDepositors = loadJson("/tmp/av1_additional_depositors.json");
  const av1AllTokens: AllTokensData = loadJson("/tmp/av1_all_tokens.json");

  // Build complete V1 depositor map
  const av1Depositors = new Map<string, bigint>();

  // Add mapped depositors from main resolution
  for (const [addr, amount] of Object.entries(av1Resolved.depositor_amounts)) {
    const existing = av1Depositors.get(addr.toLowerCase()) ?? 0n;
    av1Depositors.set(addr.toLowerCase(), existing + BigInt(amount));
  }

  // Add unmapped tokens resolved via additional depositors
  for (const [tokenId, depositor] of Object.entries(av1Additional)) {
    const amount = av1AllTokens.token_amounts[tokenId];
    if (amount === undefined) {
      console.warn(`   âš ï¸  Token ${tokenId} not found in av1_all_tokens`);
      continue;
    }
    const existing = av1Depositors.get(depositor.toLowerCase()) ?? 0n;
    av1Depositors.set(depositor.toLowerCase(), existing + BigInt(amount));
  }

  // Also add the 2 remaining unmapped tokens (5599 and 5845)
  // These were resolved in the previous session via deposit event tx senders
  // 5845 -> 0xe8d176dc1adc732a838e2056109be4c34d1dfb57
  // 5599 -> 0x24c9496b9be8572ea1d80b8fdfa720dd2584aa9e
  const manualResolutions: Record<string, string> = {
    "5845": "0xe8d176dc1adc732a838e2056109be4c34d1dfb57",
    "5599": "0x24c9496b9be8572ea1d80b8fdfa720dd2584aa9e",
  };

  for (const [tokenId, depositor] of Object.entries(manualResolutions)) {
    // Check if this token is already in the additional depositors file
    if (av1Additional[tokenId]) continue;

    const amount = av1AllTokens.token_amounts[tokenId];
    if (amount === undefined) continue;
    const existing = av1Depositors.get(depositor.toLowerCase()) ?? 0n;
    av1Depositors.set(depositor.toLowerCase(), existing + BigInt(amount));
  }

  const av1Total = [...av1Depositors.values()].reduce((a, b) => a + b, 0n);
  console.log(`   AV1: ${av1Depositors.size} depositors, total ${Number(av1Total) / 1e6} stkscUSD`);

  // Auto Voter V2 USD
  const av2Usd: ResolvedData = loadJson("/tmp/auto_voter_v2_usd_resolved.json");
  const av2UsdDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(av2Usd.depositor_amounts)) {
    av2UsdDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const av2UsdTotal = [...av2UsdDepositors.values()].reduce((a, b) => a + b, 0n);
  console.log(`   AV2 USD: ${av2UsdDepositors.size} depositors, total ${Number(av2UsdTotal) / 1e6} stkscUSD`);

  // Auto Voter V2 ETH
  const av2Eth: ResolvedData = loadJson("/tmp/auto_voter_v2_eth_resolved.json");
  const av2EthDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(av2Eth.depositor_amounts)) {
    av2EthDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const av2EthTotal = [...av2EthDepositors.values()].reduce((a, b) => a + b, 0n);
  console.log(`   AV2 ETH: ${av2EthDepositors.size} depositors, total ${Number(av2EthTotal) / 1e18} stkscETH`);

  // Withdraw Queues
  const wqData: WithdrawQueueData = loadJson("/tmp/withdraw_queues_resolved.json");
  const usdWqDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(wqData.usd_withdraw_queue.depositor_amounts)) {
    usdWqDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const usdWqTotal = [...usdWqDepositors.values()].reduce((a, b) => a + b, 0n);
  console.log(`   USD WQ: ${usdWqDepositors.size} depositors, total ${Number(usdWqTotal) / 1e6} stkscUSD`);

  const ethWqDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(wqData.eth_withdraw_queue.depositor_amounts)) {
    ethWqDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const ethWqTotal = [...ethWqDepositors.values()].reduce((a, b) => a + b, 0n);
  console.log(`   ETH WQ: ${ethWqDepositors.size} depositors, total ${Number(ethWqTotal) / 1e18} stkscETH`);

  // â”€â”€ Verify amounts match what's in the snapshot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ” Verifying amounts match snapshot...");

  // Auto voter V1 should match its snapshot entry (269,374,810,615)
  const av1SnapshotEntry = snapshot.entitlements.find(
    (e) => e.address.toLowerCase() === AUTO_VOTER_V1
  );
  if (!av1SnapshotEntry) {
    console.error("âŒ Auto Voter V1 not found in snapshot");
    process.exit(1);
  }
  const av1SnapshotBalance = BigInt(av1SnapshotEntry.stkscUSD_balance);
  console.log(`   AV1 snapshot: ${av1SnapshotBalance}, resolved: ${av1Total}, diff: ${av1Total - av1SnapshotBalance}`);

  // AV2 USD
  const av2UsdEntry = snapshot.entitlements.find(
    (e) => e.address.toLowerCase() === AUTO_VOTER_V2_USD
  );
  if (!av2UsdEntry) {
    console.error("âŒ Auto Voter V2 USD not found in snapshot");
    process.exit(1);
  }
  const av2UsdSnapshotBalance = BigInt(av2UsdEntry.stkscUSD_balance);
  console.log(`   AV2 USD snapshot: ${av2UsdSnapshotBalance}, resolved: ${av2UsdTotal}, diff: ${av2UsdTotal - av2UsdSnapshotBalance}`);

  // AV2 ETH
  const av2EthEntry = snapshot.entitlements.find(
    (e) => e.address.toLowerCase() === AUTO_VOTER_V2_ETH
  );
  if (!av2EthEntry) {
    console.error("âŒ Auto Voter V2 ETH not found in snapshot");
    process.exit(1);
  }
  const av2EthSnapshotBalance = BigInt(av2EthEntry.stkscETH_balance);
  console.log(`   AV2 ETH snapshot: ${av2EthSnapshotBalance}, resolved: ${av2EthTotal}, diff: ${av2EthTotal - av2EthSnapshotBalance}`);

  // â”€â”€ Step 1: Remove auto voter entries and undo WQ pro-rata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ”§ Step 1: Remove auto voter entries and undo WQ redistribution...");

  // The withdraw queue balances were redistributed pro-rata across ALL resolved holders.
  // Formula used in snapshot.ts (lines 633-661):
  //   for each holder: share = (holderBalance * unresolvableBalance) / resolvedTotal
  //   holder gets: holderBalance + share
  //
  // To undo: we need to compute what each holder's balance would be WITHOUT the redistribution.
  // If the final balance = originalBalance + (originalBalance * wqBalance) / resolvedTotal
  // Then: finalBalance = originalBalance * (1 + wqBalance/resolvedTotal)
  // So: originalBalance = finalBalance * resolvedTotal / (resolvedTotal + wqBalance)
  //
  // But we also need to account for the auto voter entries being part of "resolved" during redistribution.
  // The auto voter entries received their share of the WQ pro-rata too.
  //
  // Let's think differently:
  // After resolution but BEFORE redistribution, resolvedTotal = totalSupply - WQ_balance
  // After redistribution, the sum becomes totalSupply (which is correct).
  //
  // resolvedTotal_before_redistribution = totalSupply - sum(wqBalances)
  // For USD: resolvedTotal = totalSupply - usdWqTotal
  // Each holder's original balance = finalBalance / (1 + usdWqTotal/resolvedTotal)
  //                                = finalBalance * resolvedTotal / totalSupply

  const usdResolvedBeforeRedist = usdTotalSupply - usdWqTotal;
  const ethResolvedBeforeRedist = ethTotalSupply - ethWqTotal;

  console.log(`   USD resolved before redistribution: ${usdResolvedBeforeRedist} (totalSupply ${usdTotalSupply} - WQ ${usdWqTotal})`);
  console.log(`   ETH resolved before redistribution: ${ethResolvedBeforeRedist} (totalSupply ${ethTotalSupply} - WQ ${ethWqTotal})`);

  // Build new entitlements map
  const newBalances = new Map<string, { usd: bigint; eth: bigint; label?: string }>();

  let removedUsd = 0n;
  let removedEth = 0n;
  let undoneUsdRedist = 0n;
  let undoneEthRedist = 0n;

  for (const entry of snapshot.entitlements) {
    const addr = entry.address.toLowerCase();

    // Skip auto voter contract entries entirely
    if (CONTRACTS_TO_REMOVE.has(addr)) {
      removedUsd += BigInt(entry.stkscUSD_balance);
      removedEth += BigInt(entry.stkscETH_balance);
      continue;
    }

    let usdBalance = BigInt(entry.stkscUSD_balance);
    let ethBalance = BigInt(entry.stkscETH_balance);

    // Undo pro-rata redistribution of USD WQ balance
    if (usdBalance > 0n && usdWqTotal > 0n) {
      // originalBalance = finalBalance * resolvedBeforeRedist / totalSupply
      const originalUsd = (usdBalance * usdResolvedBeforeRedist) / usdTotalSupply;
      undoneUsdRedist += usdBalance - originalUsd;
      usdBalance = originalUsd;
    }

    // Undo pro-rata redistribution of ETH WQ balance
    if (ethBalance > 0n && ethWqTotal > 0n) {
      const originalEth = (ethBalance * ethResolvedBeforeRedist) / ethTotalSupply;
      undoneEthRedist += ethBalance - originalEth;
      ethBalance = originalEth;
    }

    if (usdBalance > 0n || ethBalance > 0n) {
      newBalances.set(addr, {
        usd: usdBalance,
        eth: ethBalance,
        label: entry.label,
      });
    }
  }

  console.log(`   Removed ${CONTRACTS_TO_REMOVE.size} auto voter entries:`);
  console.log(`     USD: ${removedUsd} (${Number(removedUsd) / 1e6} stkscUSD)`);
  console.log(`     ETH: ${removedEth} (${Number(removedEth) / 1e18} stkscETH)`);
  console.log(`   Undone WQ redistribution:`);
  console.log(`     USD: ${undoneUsdRedist} (${Number(undoneUsdRedist) / 1e6} stkscUSD)`);
  console.log(`     ETH: ${undoneEthRedist} (${Number(undoneEthRedist) / 1e18} stkscETH)`);

  // â”€â”€ Step 2: Add correctly attributed amounts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ”§ Step 2: Adding correctly attributed amounts...");

  function addToBalances(
    depositors: Map<string, bigint>,
    field: "usd" | "eth",
    label: string
  ) {
    let added = 0;
    let augmented = 0;
    for (const [addr, amount] of depositors) {
      const existing = newBalances.get(addr);
      if (existing) {
        existing[field] += amount;
        augmented++;
      } else {
        newBalances.set(addr, {
          usd: field === "usd" ? amount : 0n,
          eth: field === "eth" ? amount : 0n,
        });
        added++;
      }
    }
    console.log(`   ${label}: ${augmented} augmented, ${added} new addresses`);
  }

  addToBalances(av1Depositors, "usd", "Auto Voter V1");
  addToBalances(av2UsdDepositors, "usd", "Auto Voter V2 USD");
  addToBalances(av2EthDepositors, "eth", "Auto Voter V2 ETH");
  addToBalances(usdWqDepositors, "usd", "USD Withdraw Queue");
  addToBalances(ethWqDepositors, "eth", "ETH Withdraw Queue");

  // â”€â”€ Step 3: Verify totals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nâœ… Verifying totals...");

  let newUsdSum = 0n;
  let newEthSum = 0n;
  for (const { usd, eth } of newBalances.values()) {
    newUsdSum += usd;
    newEthSum += eth;
  }

  console.log(`   stkscUSD: sum=${newUsdSum}, totalSupply=${usdTotalSupply}`);
  console.log(`   stkscETH: sum=${newEthSum}, totalSupply=${ethTotalSupply}`);

  const usdDiff = usdTotalSupply - newUsdSum;
  const ethDiff = ethTotalSupply - newEthSum;

  console.log(`   USD diff: ${usdDiff} (${Number(usdDiff) / 1e6} stkscUSD)`);
  console.log(`   ETH diff: ${ethDiff} (${Number(ethDiff) / 1e18} stkscETH)`);

  // The diff should be small (rounding dust from division).
  // We'll handle it by distributing dust to the largest holder.
  if (usdDiff !== 0n) {
    // Find the largest USD holder and add the dust
    let maxAddr = "";
    let maxUsd = 0n;
    for (const [addr, { usd }] of newBalances) {
      if (usd > maxUsd) {
        maxUsd = usd;
        maxAddr = addr;
      }
    }
    if (maxAddr) {
      const entry = newBalances.get(maxAddr)!;
      entry.usd += usdDiff;
      console.log(`   â„¹ï¸  USD dust ${usdDiff} assigned to ${maxAddr}`);
    }
  }

  if (ethDiff !== 0n) {
    let maxAddr = "";
    let maxEth = 0n;
    for (const [addr, { eth }] of newBalances) {
      if (eth > maxEth) {
        maxEth = eth;
        maxAddr = addr;
      }
    }
    if (maxAddr) {
      const entry = newBalances.get(maxAddr)!;
      entry.eth += ethDiff;
      console.log(`   â„¹ï¸  ETH dust ${ethDiff} assigned to ${maxAddr}`);
    }
  }

  // Verify again after dust
  newUsdSum = 0n;
  newEthSum = 0n;
  for (const { usd, eth } of newBalances.values()) {
    newUsdSum += usd;
    newEthSum += eth;
  }

  console.log(`   After dust fix:`);
  console.log(`   stkscUSD: sum=${newUsdSum}, match=${newUsdSum === usdTotalSupply}`);
  console.log(`   stkscETH: sum=${newEthSum}, match=${newEthSum === ethTotalSupply}`);

  if (newUsdSum !== usdTotalSupply || newEthSum !== ethTotalSupply) {
    console.error("âŒ FATAL: Totals don't match after dust fix. Aborting.");
    process.exit(1);
  }

  // â”€â”€ Step 4: Build output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ“ Building output...");

  // Filter out zero-balance entries and sort by total balance (desc)
  const entitlements: SnapshotEntry[] = [];
  for (const [addr, { usd, eth, label }] of newBalances) {
    if (usd === 0n && eth === 0n) continue;
    entitlements.push({
      address: addr,
      ...(label ? { label } : {}),
      stkscUSD_balance: usd.toString(),
      stkscETH_balance: eth.toString(),
      stkscUSD_share:
        usdTotalSupply > 0n
          ? ((usd * WAD) / usdTotalSupply).toString()
          : "0",
      stkscETH_share:
        ethTotalSupply > 0n
          ? ((eth * WAD) / ethTotalSupply).toString()
          : "0",
    });
  }

  // Sort by total value (eth first, then usd) â€” matching original sort
  entitlements.sort((a, b) => {
    const aEth = BigInt(a.stkscETH_balance);
    const bEth = BigInt(b.stkscETH_balance);
    if (aEth !== bEth) return aEth > bEth ? -1 : 1;
    const aUsd = BigInt(a.stkscUSD_balance);
    const bUsd = BigInt(b.stkscUSD_balance);
    if (aUsd !== bUsd) return aUsd > bUsd ? -1 : 1;
    return 0;
  });

  // Count holders per token
  const usdHolders = entitlements.filter(
    (e) => BigInt(e.stkscUSD_balance) > 0n
  ).length;
  const ethHolders = entitlements.filter(
    (e) => BigInt(e.stkscETH_balance) > 0n
  ).length;

  const output: SnapshotFile = {
    snapshotBlock: snapshot.snapshotBlock,
    timestamp: new Date().toISOString(),
    stkscUSD: {
      totalSupply: usdTotalSupply.toString(),
      decimals: 6,
      holderCount: usdHolders,
    },
    stkscETH: {
      totalSupply: ethTotalSupply.toString(),
      decimals: 18,
      holderCount: ethHolders,
    },
    recursiveResolution: {
      veUSD_holders: usdHolders,
      wstkscUSD_holders: 0,
      stkscUSD_withdrawQueue_holders: usdWqDepositors.size,
      autoVoterV1_holders: av1Depositors.size,
      autoVoterV2USD_holders: av2UsdDepositors.size,
      veETH_holders: ethHolders,
      wstkscETH_holders: 0,
      stkscETH_withdrawQueue_holders: ethWqDepositors.size,
      autoVoterV2ETH_holders: av2EthDepositors.size,
    },
    entitlements,
  };

  // Write output
  const outputDir = path.join(scriptDir, "output");
  fs.mkdirSync(outputDir, { recursive: true });
  const outputPath = path.join(
    outputDir,
    `snapshot-${snapshot.snapshotBlock}.json`
  );
  fs.writeFileSync(outputPath, JSON.stringify(output, null, 2));
  console.log(`\nğŸ“ Snapshot written to: ${outputPath}`);
  console.log(`   Total unique addresses: ${entitlements.length}`);
  console.log(`   (was ${snapshot.entitlements.length})`);
  console.log(`   USD holders: ${usdHolders}`);
  console.log(`   ETH holders: ${ethHolders}`);

  // â”€â”€ Spot-check: verify target user 0xaf1bff... is now included â”€â”€â”€â”€â”€

  const targetUser = "0xaf1bff74708098db603e48aaebec1bbae03dcf11";
  const targetEntry = entitlements.find(
    (e) => e.address.toLowerCase() === targetUser
  );
  if (targetEntry) {
    console.log(`\nğŸ¯ Target user ${targetUser} found:`);
    console.log(`   stkscUSD: ${targetEntry.stkscUSD_balance} (${Number(BigInt(targetEntry.stkscUSD_balance)) / 1e6})`);
    console.log(`   stkscETH: ${targetEntry.stkscETH_balance}`);
  } else {
    console.warn(`\nâš ï¸  Target user ${targetUser} NOT found in entitlements.`);
    // Check if they appear in any of the resolved data
    console.log(`   AV1: ${av1Depositors.has(targetUser)}`);
    console.log(`   AV2 USD: ${av2UsdDepositors.has(targetUser)}`);
    console.log(`   AV2 ETH: ${av2EthDepositors.has(targetUser)}`);
    console.log(`   USD WQ: ${usdWqDepositors.has(targetUser)}`);
    console.log(`   ETH WQ: ${ethWqDepositors.has(targetUser)}`);
  }

  // â”€â”€ Summary of changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  console.log("\nğŸ“Š Summary of changes:");
  console.log(
    `   Auto Voter V1: 1 entry â†’ ${av1Depositors.size} depositors (${Number(av1Total) / 1e6} stkscUSD)`
  );
  console.log(
    `   Auto Voter V2 USD: 1 entry â†’ ${av2UsdDepositors.size} depositors (${Number(av2UsdTotal) / 1e6} stkscUSD)`
  );
  console.log(
    `   Auto Voter V2 ETH: 1 entry â†’ ${av2EthDepositors.size} depositors (${Number(av2EthTotal) / 1e18} stkscETH)`
  );
  console.log(
    `   USD Withdraw Queue: pro-rata undone â†’ ${usdWqDepositors.size} depositors (${Number(usdWqTotal) / 1e6} stkscUSD)`
  );
  console.log(
    `   ETH Withdraw Queue: pro-rata undone â†’ ${ethWqDepositors.size} depositors (${Number(ethWqTotal) / 1e18} stkscETH)`
  );
}

// â”€â”€â”€ Run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main();
