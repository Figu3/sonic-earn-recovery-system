/**
 * Fix Snapshot Script
 *
 * Corrects the snapshot-62788943.json by:
 *
 * The original snapshot already recursively resolved auto voter V1, V2 USD,
 * and V2 ETH into individual depositor entries. However, some tokens could
 * not be mapped to depositors ("unmapped") and their balances were
 * redistributed pro-rata across ALL resolved holders.
 *
 * Similarly, the withdraw queue balances could not be resolved (totalSupply()
 * reverted) and were also redistributed pro-rata.
 *
 * This script:
 * 1. Undoes the pro-rata redistribution of ALL unresolvable amounts
 * 2. Adds correctly attributed amounts to the right depositors
 *
 * Unresolvable amounts that were redistributed:
 *   - AV1 unmapped tokens: 147,456.33 stkscUSD (18 tokens, now mapped to depositors)
 *   - USD withdraw queue: 52,810.59 stkscUSD (29 depositors)
 *   - ETH withdraw queue: 12.20 stkscETH (11 depositors)
 *   - AV2 ETH token #1637: 0.584 stkscETH (1 depositor, was unmapped)
 *
 * Data sources (generated by on-chain event analysis):
 *   - /tmp/av1_additional_depositors.json (18 unmapped AV1 token -> depositor mappings)
 *   - /tmp/av1_all_tokens.json (all AV1 token IDs and amounts)
 *   - /tmp/auto_voter_v2_eth_resolved.json (AV2 ETH data including token #1637)
 *   - /tmp/withdraw_queues_resolved.json (WQ depositor data)
 *
 * Usage:
 *   npx tsx scripts/fix-snapshot.ts
 */

import * as fs from "fs";
import * as path from "path";

// ─── Types ─────────────────────────────────────────────────────────────

interface SnapshotEntry {
  address: string;
  label?: string;
  stkscUSD_balance: string;
  stkscETH_balance: string;
  stkscUSD_share: string;
  stkscETH_share: string;
}

interface SnapshotFile {
  snapshotBlock: number;
  timestamp: string;
  stkscUSD: {
    totalSupply: string;
    decimals: number;
    holderCount: number;
  };
  stkscETH: {
    totalSupply: string;
    decimals: number;
    holderCount: number;
  };
  recursiveResolution: Record<string, number>;
  entitlements: SnapshotEntry[];
}

interface AllTokensData {
  all_token_ids: number[];
  token_amounts: Record<string, number>;
  unmapped_token_ids: number[];
  total_locked: number;
  mapped_amount: number;
  unmapped_amount: number;
}

interface AdditionalDepositors {
  [tokenId: string]: string; // tokenId -> depositor address
}

interface WithdrawQueueData {
  usd_withdraw_queue: {
    depositor_amounts: Record<string, number>;
    total_shares: number;
    depositor_count: number;
  };
  eth_withdraw_queue: {
    depositor_amounts: Record<string, number>;
    total_shares: number;
    depositor_count: number;
  };
}

interface ResolvedData {
  depositor_amounts: Record<string, number>;
  total_locked: number;
  token_amounts: Record<string, number>;
  token_ids: number[];
}

function loadJson<T>(filePath: string): T {
  return JSON.parse(fs.readFileSync(filePath, "utf-8"));
}

// ─── Main ──────────────────────────────────────────────────────────────

function main() {
  const scriptDir = path.dirname(
    decodeURIComponent(new URL(import.meta.url).pathname)
  );
  const snapshotPath = path.join(scriptDir, "output", "snapshot-62788943.json");

  console.log("Loading snapshot...");
  const snapshot: SnapshotFile = loadJson(snapshotPath);
  console.log(`   Block: ${snapshot.snapshotBlock}`);
  console.log(`   Entries: ${snapshot.entitlements.length}`);

  const usdTotalSupply = BigInt(snapshot.stkscUSD.totalSupply);
  const ethTotalSupply = BigInt(snapshot.stkscETH.totalSupply);
  const WAD = 10n ** 18n;

  // ── Load resolved data ──────────────────────────────────────────────

  console.log("\nLoading resolved data...");

  // AV1 unmapped depositors
  const av1Additional: AdditionalDepositors = loadJson(
    "/tmp/av1_additional_depositors.json"
  );
  const av1AllTokens: AllTokensData = loadJson("/tmp/av1_all_tokens.json");

  // Build AV1 unmapped depositor amounts
  const av1UnmappedDepositors = new Map<string, bigint>();
  for (const [tokenId, depositor] of Object.entries(av1Additional)) {
    const amount = av1AllTokens.token_amounts[tokenId];
    if (amount === undefined) {
      console.warn(`   Warning: Token ${tokenId} not in av1_all_tokens`);
      continue;
    }
    const addr = depositor.toLowerCase();
    const existing = av1UnmappedDepositors.get(addr) ?? 0n;
    av1UnmappedDepositors.set(addr, existing + BigInt(amount));
  }

  const av1UnmappedTotal = [...av1UnmappedDepositors.values()].reduce(
    (a, b) => a + b,
    0n
  );
  console.log(
    `   AV1 unmapped: ${av1UnmappedDepositors.size} depositors, ` +
      `${Number(av1UnmappedTotal) / 1e6} stkscUSD`
  );

  // Verify unmapped total matches expected
  if (av1UnmappedTotal !== BigInt(av1AllTokens.unmapped_amount)) {
    console.error(
      `   MISMATCH: expected ${av1AllTokens.unmapped_amount}, got ${av1UnmappedTotal}`
    );
    process.exit(1);
  }

  // AV2 ETH token #1637 (unmapped)
  const av2Eth: ResolvedData = loadJson(
    "/tmp/auto_voter_v2_eth_resolved.json"
  );
  const av2EthToken1637Amount = BigInt(av2Eth.token_amounts["1637"]);
  const av2EthToken1637Depositor =
    "0x697f27643eed4d13276a126a31f0e84eeff92de8";
  console.log(
    `   AV2 ETH #1637: ${Number(av2EthToken1637Amount) / 1e18} stkscETH -> ${av2EthToken1637Depositor}`
  );

  // Withdraw queues
  const wqData: WithdrawQueueData = loadJson(
    "/tmp/withdraw_queues_resolved.json"
  );

  const usdWqDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(
    wqData.usd_withdraw_queue.depositor_amounts
  )) {
    usdWqDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const usdWqTotal = [...usdWqDepositors.values()].reduce(
    (a, b) => a + b,
    0n
  );
  console.log(
    `   USD WQ: ${usdWqDepositors.size} depositors, ${Number(usdWqTotal) / 1e6} stkscUSD`
  );

  const ethWqDepositors = new Map<string, bigint>();
  for (const [addr, amount] of Object.entries(
    wqData.eth_withdraw_queue.depositor_amounts
  )) {
    ethWqDepositors.set(addr.toLowerCase(), BigInt(amount));
  }
  const ethWqTotal = [...ethWqDepositors.values()].reduce(
    (a, b) => a + b,
    0n
  );
  console.log(
    `   ETH WQ: ${ethWqDepositors.size} depositors, ${Number(ethWqTotal) / 1e18} stkscETH`
  );

  // ── Calculate total unresolvable amounts ──────────────────────────

  const totalUsdUnresolvable = usdWqTotal + av1UnmappedTotal;
  const totalEthUnresolvable = ethWqTotal + av2EthToken1637Amount;

  console.log(
    `\n   Total USD unresolvable: ${Number(totalUsdUnresolvable) / 1e6} stkscUSD`
  );
  console.log(
    `   Total ETH unresolvable: ${Number(totalEthUnresolvable) / 1e18} stkscETH`
  );

  // resolvedBeforeRedist = totalSupply - totalUnresolvable
  const usdResolvedBefore = usdTotalSupply - totalUsdUnresolvable;
  const ethResolvedBefore = ethTotalSupply - totalEthUnresolvable;

  console.log(
    `   USD resolved before redistribution: ${usdResolvedBefore}`
  );
  console.log(
    `   ETH resolved before redistribution: ${ethResolvedBefore}`
  );

  // ── Step 1: Undo pro-rata redistribution ──────────────────────────

  console.log("\nStep 1: Undo pro-rata redistribution...");

  const newBalances = new Map<
    string,
    { usd: bigint; eth: bigint; label?: string }
  >();

  let undoneUsd = 0n;
  let undoneEth = 0n;

  for (const entry of snapshot.entitlements) {
    const addr = entry.address.toLowerCase();
    let usdBalance = BigInt(entry.stkscUSD_balance);
    let ethBalance = BigInt(entry.stkscETH_balance);

    // Undo pro-rata redistribution:
    // originalBalance = finalBalance * resolvedBefore / totalSupply
    if (usdBalance > 0n && totalUsdUnresolvable > 0n) {
      const originalUsd =
        (usdBalance * usdResolvedBefore) / usdTotalSupply;
      undoneUsd += usdBalance - originalUsd;
      usdBalance = originalUsd;
    }

    if (ethBalance > 0n && totalEthUnresolvable > 0n) {
      const originalEth =
        (ethBalance * ethResolvedBefore) / ethTotalSupply;
      undoneEth += ethBalance - originalEth;
      ethBalance = originalEth;
    }

    if (usdBalance > 0n || ethBalance > 0n) {
      newBalances.set(addr, {
        usd: usdBalance,
        eth: ethBalance,
        label: entry.label,
      });
    }
  }

  console.log(
    `   Undone USD redistribution: ${Number(undoneUsd) / 1e6} stkscUSD`
  );
  console.log(
    `   Undone ETH redistribution: ${Number(undoneEth) / 1e18} stkscETH`
  );

  // ── Step 2: Add correctly attributed amounts ────────────────────

  console.log("\nStep 2: Adding correctly attributed amounts...");

  function addToBalances(
    depositors: Map<string, bigint>,
    field: "usd" | "eth",
    label: string
  ) {
    let added = 0;
    let augmented = 0;
    for (const [addr, amount] of depositors) {
      const existing = newBalances.get(addr);
      if (existing) {
        existing[field] += amount;
        augmented++;
      } else {
        newBalances.set(addr, {
          usd: field === "usd" ? amount : 0n,
          eth: field === "eth" ? amount : 0n,
        });
        added++;
      }
    }
    console.log(
      `   ${label}: ${augmented} augmented, ${added} new addresses`
    );
  }

  // Add AV1 unmapped depositors (USD)
  addToBalances(av1UnmappedDepositors, "usd", "AV1 unmapped");

  // Add AV2 ETH token #1637 depositor
  const av2Eth1637Map = new Map<string, bigint>();
  av2Eth1637Map.set(av2EthToken1637Depositor, av2EthToken1637Amount);
  addToBalances(av2Eth1637Map, "eth", "AV2 ETH #1637");

  // Add USD withdraw queue depositors
  addToBalances(usdWqDepositors, "usd", "USD Withdraw Queue");

  // Add ETH withdraw queue depositors
  addToBalances(ethWqDepositors, "eth", "ETH Withdraw Queue");

  // ── Step 3: Verify totals ─────────────────────────────────────────

  console.log("\nVerifying totals...");

  let newUsdSum = 0n;
  let newEthSum = 0n;
  for (const { usd, eth } of newBalances.values()) {
    newUsdSum += usd;
    newEthSum += eth;
  }

  console.log(`   stkscUSD: sum=${newUsdSum}, supply=${usdTotalSupply}`);
  console.log(`   stkscETH: sum=${newEthSum}, supply=${ethTotalSupply}`);

  const usdDiff = usdTotalSupply - newUsdSum;
  const ethDiff = ethTotalSupply - newEthSum;

  console.log(
    `   USD diff: ${usdDiff} (${Number(usdDiff) / 1e6} stkscUSD)`
  );
  console.log(
    `   ETH diff: ${ethDiff} (${Number(ethDiff) / 1e18} stkscETH)`
  );

  // Distribute rounding dust to the largest holder
  if (usdDiff !== 0n) {
    let maxAddr = "";
    let maxUsd = 0n;
    for (const [addr, { usd }] of newBalances) {
      if (usd > maxUsd) {
        maxUsd = usd;
        maxAddr = addr;
      }
    }
    if (maxAddr) {
      newBalances.get(maxAddr)!.usd += usdDiff;
      console.log(`   USD dust ${usdDiff} assigned to ${maxAddr}`);
    }
  }

  if (ethDiff !== 0n) {
    let maxAddr = "";
    let maxEth = 0n;
    for (const [addr, { eth }] of newBalances) {
      if (eth > maxEth) {
        maxEth = eth;
        maxAddr = addr;
      }
    }
    if (maxAddr) {
      newBalances.get(maxAddr)!.eth += ethDiff;
      console.log(`   ETH dust ${ethDiff} assigned to ${maxAddr}`);
    }
  }

  // Final verification
  newUsdSum = 0n;
  newEthSum = 0n;
  for (const { usd, eth } of newBalances.values()) {
    newUsdSum += usd;
    newEthSum += eth;
  }

  console.log(`   After dust fix:`);
  console.log(
    `   stkscUSD match: ${newUsdSum === usdTotalSupply}`
  );
  console.log(
    `   stkscETH match: ${newEthSum === ethTotalSupply}`
  );

  if (newUsdSum !== usdTotalSupply || newEthSum !== ethTotalSupply) {
    console.error("FATAL: Totals don't match. Aborting.");
    process.exit(1);
  }

  // ── Step 4: Build output ──────────────────────────────────────────

  console.log("\nBuilding output...");

  const entitlements: SnapshotEntry[] = [];
  for (const [addr, { usd, eth, label }] of newBalances) {
    if (usd === 0n && eth === 0n) continue;
    entitlements.push({
      address: addr,
      ...(label ? { label } : {}),
      stkscUSD_balance: usd.toString(),
      stkscETH_balance: eth.toString(),
      stkscUSD_share:
        usdTotalSupply > 0n
          ? ((usd * WAD) / usdTotalSupply).toString()
          : "0",
      stkscETH_share:
        ethTotalSupply > 0n
          ? ((eth * WAD) / ethTotalSupply).toString()
          : "0",
    });
  }

  // Sort by total value (eth first, then usd)
  entitlements.sort((a, b) => {
    const aEth = BigInt(a.stkscETH_balance);
    const bEth = BigInt(b.stkscETH_balance);
    if (aEth !== bEth) return aEth > bEth ? -1 : 1;
    const aUsd = BigInt(a.stkscUSD_balance);
    const bUsd = BigInt(b.stkscUSD_balance);
    if (aUsd !== bUsd) return aUsd > bUsd ? -1 : 1;
    return 0;
  });

  const usdHolders = entitlements.filter(
    (e) => BigInt(e.stkscUSD_balance) > 0n
  ).length;
  const ethHolders = entitlements.filter(
    (e) => BigInt(e.stkscETH_balance) > 0n
  ).length;

  const output: SnapshotFile = {
    snapshotBlock: snapshot.snapshotBlock,
    timestamp: new Date().toISOString(),
    stkscUSD: {
      totalSupply: usdTotalSupply.toString(),
      decimals: 6,
      holderCount: usdHolders,
    },
    stkscETH: {
      totalSupply: ethTotalSupply.toString(),
      decimals: 18,
      holderCount: ethHolders,
    },
    recursiveResolution: {
      ...snapshot.recursiveResolution,
      autoVoterV1_holders:
        snapshot.recursiveResolution.autoVoterV1_holders +
        av1UnmappedDepositors.size,
      autoVoterV2ETH_holders:
        snapshot.recursiveResolution.autoVoterV2ETH_holders + 1,
      note_fixes_applied: 1,
    },
    entitlements,
  };

  // Write output (overwrites original)
  const outputDir = path.join(scriptDir, "output");
  fs.mkdirSync(outputDir, { recursive: true });
  const outputPath = path.join(
    outputDir,
    `snapshot-${snapshot.snapshotBlock}-fixed.json`
  );
  fs.writeFileSync(outputPath, JSON.stringify(output, null, 2));
  console.log(`\nSnapshot written to: ${outputPath}`);
  console.log(`   Total unique addresses: ${entitlements.length}`);
  console.log(`   (was ${snapshot.entitlements.length})`);
  console.log(`   USD holders: ${usdHolders}`);
  console.log(`   ETH holders: ${ethHolders}`);

  // ── Spot checks ───────────────────────────────────────────────────

  console.log("\nSpot checks:");

  // Check missing depositors are now included
  const missingAddrs = [
    "0x38aed5923c16e1777c981d1dbe955fefce8e20c4", // 4691
    "0xba181deb98afc2202202c9aebf26b18f46d70497", // 4740
    "0xc70aa0bc5c372ca2006204c91af480dacf621bac", // 4861+5145
    "0x1fcd2c55ae99c01f4200657a9f472c05c85b420a", // 5511+6412
    "0x8c3a8873348fa28e9b855080646fec43c39f4a05", // 5990
    "0xe9d62b53622ff203ba106dbafcd04fe5ac87261a", // 6103
    "0x7fb778baaa42d224ed6866334ed985f5d1105f3d", // 6785
    "0x9f8460b720f0ea9bc98515e9d6e427b9ac611cae", // 6864
    "0x697f27643eed4d13276a126a31f0e84eeff92de8", // AV2 ETH #1637
  ];

  for (const addr of missingAddrs) {
    const entry = entitlements.find(
      (e) => e.address.toLowerCase() === addr
    );
    if (entry) {
      const usd = Number(BigInt(entry.stkscUSD_balance)) / 1e6;
      const eth = Number(BigInt(entry.stkscETH_balance)) / 1e18;
      console.log(
        `   ${addr}: USD=${usd.toFixed(2)}, ETH=${eth.toFixed(6)}`
      );
    } else {
      console.log(`   ${addr}: NOT FOUND`);
    }
  }

  // Check target user
  const targetUser = "0xaf1bff74708098db603e48aaebec1bbae03dcf11";
  const targetEntry = entitlements.find(
    (e) => e.address.toLowerCase() === targetUser
  );
  if (targetEntry) {
    console.log(
      `\n   Target user ${targetUser}: USD=${Number(BigInt(targetEntry.stkscUSD_balance)) / 1e6}`
    );
  }

  // ── Summary ───────────────────────────────────────────────────────

  console.log("\nSummary of changes:");
  console.log(
    `   AV1 unmapped: 18 tokens -> ${av1UnmappedDepositors.size} depositors (${Number(av1UnmappedTotal) / 1e6} stkscUSD)`
  );
  console.log(
    `   AV2 ETH #1637: 1 token -> 1 depositor (${Number(av2EthToken1637Amount) / 1e18} stkscETH)`
  );
  console.log(
    `   USD WQ: ${usdWqDepositors.size} depositors (${Number(usdWqTotal) / 1e6} stkscUSD)`
  );
  console.log(
    `   ETH WQ: ${ethWqDepositors.size} depositors (${Number(ethWqTotal) / 1e18} stkscETH)`
  );
  console.log(
    `   Pro-rata redistribution undone: ${Number(undoneUsd) / 1e6} stkscUSD, ${Number(undoneEth) / 1e18} stkscETH`
  );
}

// ─── Run ───────────────────────────────────────────────────────────────

main();
